{"version":3,"file":"fetch-token.js","sourceRoot":"","sources":["../../src/fetch-token.ts"],"names":[],"mappings":";AAAA;gBACgB;;;AAEhB,6CAAuC;AAIvC,MAAM,4BAA4B,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;AAoBnD,SAAgB,UAAU,CACxB,GAAW,EACX,cAAoC;IAEpC,MAAM,OAAO,GAAoB,cAAc,CAAC;IAEhD,8DAA8D;IAC9D,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC;IAE5B,OAAO,IAAA,oBAAO,EAAC,GAAG,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,QAAgC,EAAE,EAAE;QACrE,MAAM,CAAC,GAAwB;YAC7B,KAAK,EAAE,QAAQ,CAAC,YAAY;YAC5B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,OAAO,EAAE,IAAI,IAAI;YACf,+HAA+H;YAC/H,qGAAqG;YACrG,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC,UAAU,GAAG,IAAI,GAAG,4BAA4B,CACvE;YACD,GAAG,EAAE,QAAQ,CAAC,GAAG,KAAK,IAAI;SAC3B,CAAC;QAEF,IAAI,QAAQ,CAAC,aAAa,EAAE;YAC1B,CAAC,CAAC,YAAY,GAAG,QAAQ,CAAC,aAAa,CAAC;SACzC;QAED,IAAI,QAAQ,CAAC,wBAAwB,EAAE;YACrC,CAAC,CAAC,mBAAmB,GAAG,IAAI,IAAI;YAC9B,+HAA+H;YAC/H,qGAAqG;YACrG,IAAI,CAAC,GAAG,EAAE;gBACR,QAAQ,CAAC,wBAAwB,GAAG,IAAI;gBACxC,4BAA4B,CAC/B,CAAC;SACH;QAED,OAAO,CAAC,CAAC;IACX,CAAC,CAAC,CAAC;AACL,CAAC;AArCD,gCAqCC","sourcesContent":["/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { ITokenRequestOptions } from \"./utils/ITokenRequestOptions.js\";\n\nconst FIVE_MINUTES_IN_MILLISECONDS = 5 * 60 * 1000;\n\ninterface IFetchTokenRawResponse {\n  access_token: string;\n  expires_in: number;\n  username: string;\n  ssl?: boolean;\n  refresh_token?: string;\n  refresh_token_expires_in?: number;\n}\n\nexport interface IFetchTokenResponse {\n  token: string;\n  expires: Date;\n  username: string;\n  ssl: boolean;\n  refreshToken?: string;\n  refreshTokenExpires?: Date;\n}\n\nexport function fetchToken(\n  url: string,\n  requestOptions: ITokenRequestOptions\n): Promise<IFetchTokenResponse> {\n  const options: IRequestOptions = requestOptions;\n\n  // we generate a response, so we can't return the raw response\n  options.rawResponse = false;\n\n  return request(url, options).then((response: IFetchTokenRawResponse) => {\n    const r: IFetchTokenResponse = {\n      token: response.access_token,\n      username: response.username,\n      expires: new Date(\n        // convert seconds in response to milliseconds and add the value to the current time to calculate a static expiration timestamp\n        // we subtract 5 minutes here to make sure that we refresh the token early if the user makes requests\n        Date.now() + response.expires_in * 1000 - FIVE_MINUTES_IN_MILLISECONDS\n      ),\n      ssl: response.ssl === true\n    };\n\n    if (response.refresh_token) {\n      r.refreshToken = response.refresh_token;\n    }\n\n    if (response.refresh_token_expires_in) {\n      r.refreshTokenExpires = new Date(\n        // convert seconds in response to milliseconds and add the value to the current time to calculate a static expiration timestamp\n        // we subtract 5 minutes here to make sure that we refresh the token early if the user makes requests\n        Date.now() +\n          response.refresh_token_expires_in * 1000 -\n          FIVE_MINUTES_IN_MILLISECONDS\n      );\n    }\n\n    return r;\n  });\n}\n"]}